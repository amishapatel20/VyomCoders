# -*- coding: utf-8 -*-
"""Fire spread predictor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V_UwumiR0EuivY3q_NSxJe1mJp89psx8
"""

import zipfile, os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from xgboost import XGBRegressor
import imageio
from PIL import Image
from IPython.display import HTML, display
import folium
from folium.plugins import HeatMap

"""#Uploading of Dataset"""

uploaded = files.upload()
pauri_zip = list(uploaded.keys())[0]
uttarkashi_zip = list(uploaded.keys())[1]

pauri_path = '/content/pauri_data'
uttarkashi_path = '/content/uttarkashi_data'
os.makedirs(pauri_path, exist_ok=True)
os.makedirs(uttarkashi_path, exist_ok=True)

with zipfile.ZipFile(pauri_zip, 'r') as zip_ref:
    zip_ref.extractall(pauri_path)
with zipfile.ZipFile(uttarkashi_zip, 'r') as zip_ref:
    zip_ref.extractall(uttarkashi_path)

def load_folder(path):
    data = {}
    for file in os.listdir(path):
        if file.endswith('.csv'):
            df = pd.read_csv(os.path.join(path, file))
            print(f"\nLoaded {file} with shape: {df.shape}")
            print(df.describe(include='all').T.head())
            data[file] = df
    return data

pauri_data = load_folder(pauri_path)
uttarkashi_data = load_folder(uttarkashi_path)

"""#Preprocessing"""

def preprocess(df):
    print("\nBefore preprocessing:")
    print(df.isnull().sum())
    df = df.fillna(df.mean(numeric_only=True))
    df['valid_time'] = pd.date_range(start='2023-01-01', periods=len(df), freq='h')
    scaler = MinMaxScaler()
    df[df.select_dtypes(include=np.number).columns] = scaler.fit_transform(df.select_dtypes(include=np.number))
    df = df.set_index('valid_time').resample('D').mean()
    print("After preprocessing:")
    print(df.head())
    return df

for k in pauri_data:
    pauri_data[k] = preprocess(pauri_data[k])

"""#Data Visualization"""

def plot_timeseries(df, column, title, ylabel, color):
    if column in df.columns:
        plt.figure(figsize=(10, 4))
        df[column].plot(color=color)
        plt.title(title)
        plt.xlabel('Time')
        plt.ylabel(ylabel)
        plt.grid(True)
        plt.tight_layout()
        plt.show()

for name, df in pauri_data.items():
    for col in ['t2m', 'u10', 'v10', 'swvl1', 'tp']:
        if col in df.columns:
            plot_timeseries(df, col, f"{col} over Time - {name}", col.upper(), 'blue')

"""#Feature Engineering"""

merged_df = pd.DataFrame(index=next(iter(pauri_data.values())).index)
for key, df in pauri_data.items():
    merged_df = merged_df.join(df, how='outer', rsuffix=f'_{key}')

merged_df = merged_df.ffill().bfill()

merged_df['wind_speed'] = np.sqrt(merged_df.filter(like='u10').mean(axis=1)**2 + merged_df.filter(like='v10').mean(axis=1)**2)

mean_temp = merged_df.filter(like='t2m').mean(axis=1)
mean_soil = merged_df.filter(like='swvl1').mean(axis=1)

merged_df['fire_risk_score'] = (
    0.4 * mean_temp +
    0.4 * merged_df['wind_speed'] -
    0.3 * mean_soil
)
merged_df['fire_risk_score'] = MinMaxScaler().fit_transform(merged_df[['fire_risk_score']])

"""#Modelling"""

X = merged_df.drop(columns=['fire_risk_score'])
y = merged_df['fire_risk_score']

X_train, X_test, y_train, y_test = train_test_split(X, y, shuffle=False, test_size=0.2)

model = XGBRegressor(objective='reg:squarederror', n_estimators=300, learning_rate=0.05, max_depth=5)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
print(f"MSE: {mse:.4f}")

"""#Predicting Next 6 Hours"""

latitude_min, latitude_max = 30.1, 30.6
longitude_min, longitude_max = 78.5, 79.0
n_grid = 10
future_frames = 6
last_known = X_test.iloc[-(n_grid * n_grid):].copy()
future_images = []

latitudes = np.linspace(latitude_min, latitude_max, n_grid)
longitudes = np.linspace(longitude_min, longitude_max, n_grid)

importances = model.feature_importances_
feature_names = X.columns
indices = np.argsort(importances)[-10:][::-1]

plt.figure(figsize=(10, 6))
plt.barh(range(len(indices)), importances[indices], align='center')
plt.yticks(range(len(indices)), [feature_names[i] for i in indices])
plt.xlabel('Relative Importance')
plt.title('Top 10 Feature Importances in Fire Risk Prediction')
plt.gca().invert_yaxis()
plt.grid(True)
plt.tight_layout()
plt.show()

import seaborn as sns

plt.figure(figsize=(12, 10))
sns.heatmap(merged_df.corr(), cmap='coolwarm', annot=False, linewidths=0.5)
plt.title('Correlation Matrix of Input Features')
plt.show()

from scipy.ndimage import gaussian_filter
import base64
from IPython.display import HTML
import numpy as np
import matplotlib.pyplot as plt
import imageio

latitude_min, latitude_max = 30.1, 30.6
longitude_min, longitude_max = 78.5, 79.0
n_grid = 10
future_frames = 12
frame_duration = 2.5


last_known = X_test.iloc[-(n_grid * n_grid):].copy()
future_images = []
previous_frame = None

latitudes = np.linspace(latitude_min, latitude_max, n_grid)
longitudes = np.linspace(longitude_min, longitude_max, n_grid)


for t in range(future_frames):
    y_future_pred = model.predict(last_known)
    smoothed = gaussian_filter(y_future_pred.reshape(n_grid, n_grid), sigma=1.5)


    if previous_frame is not None:
        smoothed = 0.6 * smoothed + 0.4 * previous_frame
    previous_frame = smoothed.copy()


    plt.figure(figsize=(6, 6))
    plt.imshow(
        smoothed, cmap='inferno',
        extent=[longitude_min, longitude_max, latitude_min, latitude_max],
        origin='lower', vmin=0.0, vmax=1.0
    )
    plt.title(f"Predicted Fire Spread +{(t+1)}h", fontsize=14)
    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.colorbar(label="Fire Risk")
    filename = f"spread_frame_{t}.png"
    plt.savefig(filename)
    plt.close()

    future_images.append(imageio.imread(filename))


    if 't2m' in last_known.columns:
        last_known['t2m'] = 0.7 * last_known['t2m'] + 0.3 * smoothed.flatten()
    if 'swvl1' in last_known.columns:
        last_known['swvl1'] *= 0.96
    last_known *= np.random.normal(0.995, 0.01, last_known.shape)


gif_path = "realistic_fire_spread.gif"
imageio.mimsave(gif_path, future_images, duration=frame_duration)

with open(gif_path, "rb") as f:
    data_uri = base64.b64encode(f.read()).decode("utf-8")
display(HTML(f'<img src="data:image/gif;base64,{data_uri}" width="700">'))

!pip install contextily geopandas pyproj shapely

!ctx.add_basemap(ax, source=ctx.providers.Stamen.TonerLite)

import numpy as np
import matplotlib.pyplot as plt
import contextily as ctx
import geopandas as gpd
from shapely.geometry import box
from scipy.ndimage import gaussian_filter
import imageio
import base64
from IPython.display import HTML
import os


longitude_min, longitude_max = 78.5, 79.5
latitude_min, latitude_max = 29.5, 30.5
n_grid = 10
time_steps = [6, 8, 12, 24]
frames = []

bbox = box(longitude_min, latitude_min, longitude_max, latitude_max)
gdf = gpd.GeoDataFrame({'geometry': [bbox]}, crs="EPSG:4326")


lons = np.linspace(longitude_min, longitude_max, n_grid)
lats = np.linspace(latitude_min, latitude_max, n_grid)
xx, yy = np.meshgrid(lons, lats)

np.random.seed(42)
base = np.random.uniform(0.3, 0.6, size=(n_grid, n_grid))


for step, hour in enumerate(time_steps):
    fire_spread = gaussian_filter(base, sigma=1.2 + step * 0.3)
    fire_spread += 0.03 * step
    fire_spread = np.clip(fire_spread, 0, 1)

    fig, ax = plt.subplots(figsize=(8, 8))
    gdf.plot(ax=ax, edgecolor='none', alpha=0)

    heatmap = ax.imshow(
        fire_spread,
        cmap='hot',
        extent=[longitude_min, longitude_max, latitude_min, latitude_max],
        origin='lower',
        vmin=0, vmax=1,
        alpha=0.8
    )


    terrain = ctx.providers.OpenStreetMap.Mapnik
    ctx.add_basemap(ax, crs=gdf.crs.to_string(), source=terrain, zoom=10)


    ax.text(78.75, 30.1, "Pauri Garhwal", fontsize=12, color="white", weight="bold", bbox=dict(facecolor='black', alpha=0.5))


    ax.set_title(f"Predicted Fire Spread +{hour}h", fontsize=14)
    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.set_xlim(longitude_min, longitude_max)
    ax.set_ylim(latitude_min, latitude_max)
    cbar = plt.colorbar(heatmap, ax=ax, fraction=0.03, pad=0.01)
    cbar.set_label("Fire Risk")


    filename = f"/tmp/map_frame_{hour}h.png"
    plt.savefig(filename, dpi=120, bbox_inches='tight')
    plt.close()

    frames.append(imageio.imread(filename))


gif_path = "final_fire_spread.gif"
imageio.mimsave(gif_path, frames, duration=2.5)


with open(gif_path, "rb") as f:
    data_uri = base64.b64encode(f.read()).decode("utf-8")
HTML(f'<img src="data:image/gif;base64,{data_uri}" width="720">')